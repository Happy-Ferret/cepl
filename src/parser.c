/*
 * parser.c - c11 parsing and lexing functions
 *
 * AUTHOR: Joey Pabalinas <alyptik@protonmail.com>
 * See LICENSE.md file for copyright and license details.
 */

#include "parser.h"
#include <stdlib.h>
#include <string.h>

/* symbol types */
enum sym_type {
	START_RULE = 0,
	TRANSLATION_UNIT, COMMENT, EXTERNAL_DECLARATION,
	FUNCTION_DEFINITION, DECLARATION, DECLARATION_SPECIFIERS,
	DECLARATOR, COMPOUND_STATEMENT, BLOCK_ITEM_LIST, BLOCK_ITEM,
	STATEMENT, STATEMENT_LIST, JUMP_STATEMENT, ITERATION_STATEMENT,
	SELECTION_STATEMENT, LABELED_STATEMENT, EXPRESSION_STATEMENT,
	FOR_EXPRESSION, FOR_INCREMENT, FOR_INITIALIZATION,
	CONDITIONAL_EXPRESSION, CONDITIONAL_TERNARY_EXPRESSION,
	ASSIGNMENT_OPERATOR, CONSTANT_EXPRESSION, LOGICAL_OR_AND_EXPRESSION,
	LOG_OR_AND_BIT_OR_AND_EQ, REL_MUL_ADD_EX_OP, UNARY_OPERATOR,
	CLOSURE, STATIC_ASSERT, STATIC_ASSERT_DECLARATION,
	DECLARATION_LIST, INIT_DECLARATOR_LIST, INIT_DECLARATOR,
	INITIALIZER, INITIALIZER_LIST, DESIGNATION, DESIGNATOR_LIST,
	DESIGNATOR, UNARY_EXPRESSION, ALIGNOF, POSTFIX_PRODUCTIONS,
	POSTFIX_EXPRESSION, POSTFIX_SUFFIX, ARGUMENT_EXPRESSION_LIST,
	NARROW_CLOSURE, PRIMARY_EXPRESSION, GENERIC_SELECTION,
	GENERIC_ASSOC_LIST, GENERIC_ASSOCIATION, ALIGNAS, ALIGNMENT_SPECIFIER,
	ARRAY_QUALIFIERS, ARRAY_DECLARATOR, IDENTIFIER_LIST,
	PARAMETER_TYPE_LIST, PARAMETER_LIST, PARAMETER_DECLARATION,
	ABSTRACT_DECLARATOR, DIRECT_ABSTRACT_DECLARATOR, DAD, IDENTIFIER,
	POINTER, TYPE_QUALIFIER_LIST, FUNCTION_SPECIFIER,
	STORAGE_CLASS_SPECIFIER, TYPE_QUALIFIER, ATOMIC_TYPE_SPECIFIER,
	TYPE_SPECIFIER, TYPEDEF_NAME, STRUCT_OR_UNION_SPECIFIER,
	STRUCT_DECLARATION_LIST, STRUCT_DECLARATION, TYPE_NAME,
	SPECIFIER_QUALIFIER_LIST, STRUCT_OR_UNION, ENUM_SPECIFIER,
	ENUMERATOR_LIST, ENUMERATOR, COMMENT_C, COMMENT_CXX,
	CONSTANT, IDENTIFIER_WORD, RESERVED,
};

/* globals */
struct var_table objects;

/* tables */
char const *symbols[] = {
	[START_RULE] = "START_RULE",
	/*
	 *   TRANSLATION_UNIT
	 * + START_RULE (?)
	 */
	[TRANSLATION_UNIT] = "TRANSLATION_UNIT",
	/*
	 *   COMMENT
	 * | EXTERNAL_DECLARATION
	 * | FUNCTION_DEFINITION
	 */
	[COMMENT] = "COMMENT",
	[EXTERNAL_DECLARATION] = "EXTERNAL_DECLARATION",
	/*
	 *   DECLARATION
	 */
	[FUNCTION_DEFINITION] = "FUNCTION_DEFINITION",
	/*
	 *   DECLARATION_SPECIFIERS[CONTEXT => 'FUNCTION DEFINITION'](?)
	 * + DECLARATOR[CONTEXT => 'FUNCTION DEFINITION']
	 * + COMPOUND_STATEMENT[CONTEXT => 'FUNCTION DEFINITION STATEMENT'](?)
	 */
	[DECLARATION_SPECIFIERS] = "DECLARATION_SPECIFIERS",
	[DECLARATOR] = "DECLARATOR",
	[COMPOUND_STATEMENT] = "COMPOUND_STATEMENT",
	/*
	 *   '{'
	 * + block_item_list(s?)
	 * + '}'
	 */
	[DECLARATION] = "DECLARATION",
	[BLOCK_ITEM_LIST] = "BLOCK_ITEM_LIST",
	/*
	 *   BLOCK_ITEM(s)
	 */
	[BLOCK_ITEM] = "BLOCK_ITEM",
	/*
	 *   DECLARATION
	 * | STATEMENT[CONTEXT => "$ARG{CONTEXT}|BLOCK ITEM"]
	 * | COMMENT
	 */
	[STATEMENT] = "STATEMENT",
	/*
	 *   JUMP_STATEMENT
	 * | COMPOUND_STATEMENT
	 * | ITERATION_STATEMENT
	 * | SELECTION_STATEMENT
	 * | LABELED_STATEMENT
	 * | EXPRESSION_STATEMENT
	 */
	[STATEMENT_LIST] = "STATEMENT_LIST",
	/*
	 *   COMMENT(?)
	 * + STATEMENT[CONTEXT => UNDEF]
	 * + STATEMENT_LIST(?)
	 */
	[JUMP_STATEMENT] = "JUMP_STATEMENT",
	[ITERATION_STATEMENT] = "ITERATION_STATEMENT",
	[SELECTION_STATEMENT] = "SELECTION_STATEMENT",
	[LABELED_STATEMENT] = "LABELED_STATEMENT",
	[EXPRESSION_STATEMENT] = "EXPRESSION_STATEMENT",
	[FOR_EXPRESSION] = "FOR_EXPRESSION",
	[FOR_INCREMENT] = "FOR_INCREMENT",
	[FOR_INITIALIZATION] = "FOR_INITIALIZATION",
	[CONDITIONAL_EXPRESSION] = "CONDITIONAL_EXPRESSION",
	[CONDITIONAL_TERNARY_EXPRESSION] = "CONDITIONAL_TERNARY_EXPRESSION",
	[ASSIGNMENT_OPERATOR] = "ASSIGNMENT_OPERATOR",
	[CONSTANT_EXPRESSION] = "CONSTANT_EXPRESSION",
	[LOGICAL_OR_AND_EXPRESSION] = "LOGICAL_OR_AND_EXPRESSION",
	[LOG_OR_AND_BIT_OR_AND_EQ] = "LOG_OR_AND_BIT_OR_AND_EQ",
	[REL_MUL_ADD_EX_OP] = "REL_MUL_ADD_EX_OP",
	[UNARY_OPERATOR] = "UNARY_OPERATOR",
	[CLOSURE] = "CLOSURE",
	[STATIC_ASSERT] = "STATIC_ASSERT",
	[STATIC_ASSERT_DECLARATION] = "STATIC_ASSERT_DECLARATION",
	[DECLARATION_LIST] = "DECLARATION_LIST",
	[INIT_DECLARATOR_LIST] = "INIT_DECLARATOR_LIST",
	[INIT_DECLARATOR] = "INIT_DECLARATOR",
	[INITIALIZER] = "INITIALIZER",
	[INITIALIZER_LIST] = "INITIALIZER_LIST",
	[DESIGNATION] = "DESIGNATION",
	[DESIGNATOR_LIST] = "DESIGNATOR_LIST",
	[DESIGNATOR] = "DESIGNATOR",
	[UNARY_EXPRESSION] = "UNARY_EXPRESSION",
	[ALIGNOF] = "ALIGNOF",
	[POSTFIX_PRODUCTIONS] = "POSTFIX_PRODUCTIONS",
	[POSTFIX_EXPRESSION] = "POSTFIX_EXPRESSION",
	[POSTFIX_SUFFIX] = "POSTFIX_SUFFIX",
	[ARGUMENT_EXPRESSION_LIST] = "ARGUMENT_EXPRESSION_LIST",
	[NARROW_CLOSURE] = "NARROW_CLOSURE",
	[PRIMARY_EXPRESSION] = "PRIMARY_EXPRESSION",
	[GENERIC_SELECTION] = "GENERIC_SELECTION",
	[GENERIC_ASSOC_LIST] = "GENERIC_ASSOC_LIST",
	[GENERIC_ASSOCIATION] = "GENERIC_ASSOCIATION",
	[ALIGNAS] = "ALIGNAS",
	[ALIGNMENT_SPECIFIER] = "ALIGNMENT_SPECIFIER",
	[ARRAY_QUALIFIERS] = "ARRAY_QUALIFIERS",
	[ARRAY_DECLARATOR] = "ARRAY_DECLARATOR",
	[IDENTIFIER_LIST] = "IDENTIFIER_LIST",
	[PARAMETER_TYPE_LIST] = "PARAMETER_TYPE_LIST",
	[PARAMETER_LIST] = "PARAMETER_LIST",
	[PARAMETER_DECLARATION] = "PARAMETER_DECLARATION",
	[ABSTRACT_DECLARATOR] = "ABSTRACT_DECLARATOR",
	[DIRECT_ABSTRACT_DECLARATOR] = "DIRECT_ABSTRACT_DECLARATOR",
	[DAD] = "DAD",
	[IDENTIFIER] = "IDENTIFIER",
	[POINTER] = "POINTER",
	[TYPE_QUALIFIER_LIST] = "TYPE_QUALIFIER_LIST",
	[FUNCTION_SPECIFIER] = "FUNCTION_SPECIFIER",
	[STORAGE_CLASS_SPECIFIER] = "STORAGE_CLASS_SPECIFIER",
	[TYPE_QUALIFIER] = "TYPE_QUALIFIER",
	[ATOMIC_TYPE_SPECIFIER] = "ATOMIC_TYPE_SPECIFIER",
	[TYPE_SPECIFIER] = "TYPE_SPECIFIER",
	[TYPEDEF_NAME] = "TYPEDEF_NAME",
	[STRUCT_OR_UNION_SPECIFIER] = "STRUCT_OR_UNION_SPECIFIER",
	[STRUCT_DECLARATION_LIST] = "STRUCT_DECLARATION_LIST",
	[STRUCT_DECLARATION] = "STRUCT_DECLARATION",
	[TYPE_NAME] = "TYPE_NAME",
	[SPECIFIER_QUALIFIER_LIST] = "SPECIFIER_QUALIFIER_LIST",
	[STRUCT_OR_UNION] = "STRUCT_OR_UNION",
	[ENUM_SPECIFIER] = "ENUM_SPECIFIER",
	[ENUMERATOR_LIST] = "ENUMERATOR_LIST",
	[ENUMERATOR] = "ENUMERATOR",
	[COMMENT_C] = "COMMENT_C",
	[COMMENT_CXX] = "COMMENT_CXX",
	[CONSTANT] = "CONSTANT",
	[IDENTIFIER_WORD] = "IDENTIFIER_WORD",
	[RESERVED] = "RESERVED",
};

/* current symbol */
static size_t sym_idx;
static struct str_list tok_list;

static void next_sym(void)
{
	sym_idx++;
#ifdef _DEBUG
	printf("prev/cur: (%s, %s)\n", tok_list.list[sym_idx - 1], tok_list.list[sym_idx]);
#endif
}

static bool accept(enum sym_type type)
{
	if (type) {
		next_sym();
		return true;
	}
	return false;
}

static bool expect(enum sym_type type)
{
	if (accept(type))
		return true;
	WARNX("%s: %s", "failure parsing symbol", symbols[type]);
	return false;
}

static void start_rule(void);
static void translation_unit(void)
{
	(void)tok_list, (void)expect, (void)start_rule;
}

static void start_rule(void)
{
	translation_unit();
}

